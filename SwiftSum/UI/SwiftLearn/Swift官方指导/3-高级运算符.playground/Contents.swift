//: Playground - noun: a place where people can play

import UIKit



// MARK: -  位运算符

// MARK: - # 按位取反运算符

//按位取反运算符（~）可以对一个数值的全部比特位进行取反：

// MARK: - # 按位与运算符

//按位与运算符（&）可以对两个数的比特位进行合并。它返回一个新的数，只有当两个数的对应位都为 1 的时候，新数的对应位才为 1：

// MARK: - # 按位或运算符

//按位或运算符（|）可以对两个数的比特位进行比较。它返回一个新的数，只要两个数的对应位中有任意一个为 1 时，新数的对应位就为 1：

// MARK: - # 按位异或运算符

//按位异或运算符（^）可以对两个数的比特位进行比较。它返回一个新的数，当两个数的对应位不相同时，新数的对应位就为 1：

// MARK: - # 按位左移、右移运算符

// MARK: -  无符号整数的移位运算

// 对无符号整数进行移位的规则如下：
//
//- 已经存在的位按指定的位数进行左移和右移。
//- 任何因移动而超出整型存储范围的位都会被丢弃。
//- 用 0 来填充移位后产生的空白位。
//- 这种方法称为逻辑移位。

// MARK: - // MARK: -  有符号整数的移位运算

//有符号整数的移位运算相对复杂得多，这种复杂性源于有符号整数的二进制表现形式。
//
//- 有符号整数使用第 1 个比特位（通常被称为符号位）来表示这个数的正负。
//- 符号位为 0 代表正数，为 1 代表负数。
//
//- 其余的比特位（通常被称为数值位）存储了实际的值。
//- 有符号正整数和无符号数的存储方式是一样的，都是从 0 开始算起。

//这是值为 4 的 Int8 型整数的二进制位表现形式：

//`0 0000100` 符号位为 0，说明这是一个正数，另外 7 位则代表了十进制数值 4 的二进制表示。

//这是值为 -4 的 Int8 型整数的二进制位表现形式：

//`1 1111100` 负数的存储方式略有不同。它存储的值的绝对值等于 2 的 n 次方减去它的实际值（也就是数值位表示的值），这里的 n 为数值位的比特位数。这里是7

//这次的符号位为 1，说明这是一个负数，另外 7 个位则代表了数值 124（即 128 - 4）的二进制表示： ` 1111100`

//<mark>负数的表示通常被称为二进制补码表示。</mark>用这种方法来表示负数乍看起来有点奇怪，但它有几个优点。

//1. 首先，如果想对 -1 和 -4 进行加法运算，我们只需要将这两个数的全部 8 个比特位进行相加，并且将计算结果中超出 8 位的数值丢弃：


//2. 其次，使用二进制补码可以使负数的按位左移和右移运算得到跟正数同样的效果，即每向左移一位就将自身的数值乘以 2，每向右一位就将自身的数值除以 2。要达到此目的，对有符号整数的右移有一个额外的规则：

//- 当对正整数进行按位右移运算时，遵循与无符号整数相同的规则，但是对于移位产生的空白位使用符号位进行填充，而不是用 0。
//- 这个行为可以确保有符号整数的符号位不会因为右移运算而改变，这通常被称为算术移位。

// MARK: -  溢出运算符

//使用 Swift 提供的三个溢出运算符来让系统支持整数溢出运算。这些运算符都是以 & 开头的：
//
//- 溢出加法 &+
//- 溢出减法 &-
//- 溢出乘法 &*

// MARK: -  优先级和结合性


//想查看完整的 Swift 运算符优先级和结合性规则，请参考表达式。

//>注意
//相对 C 语言和 Objective-C 来说，Swift 的运算符优先级和结合性规则更加简洁和可预测。但是，这也意味着它们相较于 C 语言及其衍生语言并不是完全一致的。

// MARK: -  运算符函数

//类和结构体可以为现有的运算符提供自定义的实现，这通常被称为运算符重载。

//下面的例子展示了如何为自定义的结构体实现加法运算符（+）双目中缀运算符

struct Verctor {
    var x , y: Int
}

func + (left: Verctor, right: Verctor) -> Verctor {
    return Verctor(x: left.x + right.x, y: left.y + right.y)
}

let v1 = Verctor(x: 4, y: 4)
let v2 = Verctor(x: 2, y: 2)
let v3 = v1 + v2

//该运算符函数被定义为一个全局函数，并且函数的名字与它要进行重载的 + 名字一致。

// MARK: -  前缀和后缀运算符

//要实现前缀或者后缀运算符，需要在声明运算符函数的时候在 func 关键字之前指定 prefix 或者 postfix 修饰符：

prefix func - (vecot: Verctor) -> Verctor {
    return Verctor(x: -vecot.x, y: -vecot.y)
}
let v4 = -v3

// MARK: -  复合赋值运算符
//
//复合赋值运算符将赋值运算符（=）与其它运算符进行结合。在实现的时候，需要把运算符的左参数设置成 inout 类型，因为这个参数的值会在运算符函数内直接被修改。
func += (inout left: Verctor, right: Verctor) {
    left = left + right
}
var v5 = v1
v5 += v2

//还可以将赋值与 prefix 或 postfix 修饰符结合起来，下面的代码为 Vector2D 实例实现了前缀自增运算符：
prefix func ++(inout vector: Verctor) -> Verctor {
    vector += Verctor(x: 1, y: 1)
    return vector
}
postfix func ++(inout vector: Verctor) -> Verctor {
    let ret = vector
    vector += Verctor(x: 1, y: 1)
    return ret
}
var v6 = ++v5
let v7 = v6++

//>注意
//<mark>不能对默认的赋值运算符（=）进行重载。只有组合赋值运算符可以被重载。同样地，也无法对三目条件运算符 （a ? b : c） 进行重载。

// MARK: -  等价运算符
//
//自定义的类和结构体没有对等价运算符进行默认实现，等价运算符通常被称为“相等”运算符（==）与“不等”运算符（!=）。
//
//对于自定义类型，Swift 无法判断其是否“相等”，因为“相等”的含义取决于这些自定义类型在你的代码中所扮演的角色。

//为了使用等价运算符能对自定义的类型进行判等运算，需要为其提供自定义实现

func == (left: Verctor, right: Verctor) -> Bool {
    return (left.x == right.x) && (left.y == right.y)
}
func != (left: Verctor, right: Verctor) -> Bool {
    return !(left == right)
}

if v6 == v7 {
    
}

//
//// MARK: -  自定义运算符
//
//除了实现标准运算符，在 Swift 中还可以声明和实现自定义运算符。可以用来自定义运算符的字符列表请参考[运算符。](http://wiki.jikexueyuan.com/project/swift/chapter3/02_Lexical_Structure.html#operators)

//<mark>新的运算符要使用 operator 关键字在全局作用域内进行定义，同时还要指定 prefix、infix 或者 postfix 修饰符：

//定义了一个新的名为 +++ 的前缀运算符。
prefix operator +++ {}

//实现+++ 让 Verctor 实例的 x 属性和 y 属性的值翻倍：
prefix func +++ (inout vector: Verctor)-> Verctor {
    vector += vector
    return vector
}
let v8 = +++v6

// MARK: - # 自定义中缀运算符的优先级和结合性
//
//自定义的中缀运算符也可以指定优先级和结合性。优先级和结合性中详细阐述了这两个特性是如何对中缀运算符的运算产生影响的。
//
//结合性可取的值有left，right 和 none。当左结合运算符跟其他相同优先级的左结合运算符写在一起时，会跟左边的值进行结合。同理，当右结合运算符跟其他相同优先级的右结合运算符写在一起时，会跟右边的值进行结合。而非结合运算符不能跟其他相同优先级的运算符写在一起。
//
//结合性的默认值是 none，优先级的默认值 100。
//
//以下例子定义了一个新的中缀运算符 +-，此运算符的结合性为 left，并且它的优先级为 140：
infix operator +- { associativity left precedence 140 }
func +- (left: Verctor, right: Verctor) -> Verctor {
    return Verctor(x: left.x + right.x, y: left.y - right.y)
}

let v9 = v8 +- v7

//这个运算符把两个向量的 x 值相加，同时用第一个向量的 y 值减去第二个向量的 y 值。因为它本质上是属于“相加型”运算符，所以将它的结合性和优先级被分别设置为 left 和 140，这与 + 和 - 等默认的中缀“相加型”运算符是相同的。关于 Swift 标准库提供的运算符的结合性与优先级，请参考 Swift Standard Library Operators Reference。

//>注意
//当定义前缀与后缀运算符的时候，我们并没有指定优先级。然而，<mark>如果对同一个值同时使用前缀与后缀运算符，则后缀运算符会先参与运算。
//

