//: Playground - noun: a place where people can play

import UIKit


/**
 本页内容包括：
 
 - 模块和源文件
 - 访问级别
	- 访问级别基本原则
	- 默认访问级别
	- 单 target 应用程序的访问级别
	- 框架的访问级别
	- 单元测试 target 的访问级别
 - 访问控制语法
 - 自定义类型
	- 元组类型
	- 函数类型
	- 枚举类型
	- 嵌套类型
 - 子类
 - 常量、变量、属性、下标
	- Getter和Setter
 - 构造器
	- 默认构造器
	- 结构体默认的成员逐一构造器
 - 协议
	- 协议继承
	- 协议一致性
 - 扩展
	- 通过扩展添加协议一致性
 - 泛型
 - 类型别名
 
 访问控制可以限定其他源文件或模块中的代码对你的代码的访问级别。
 */

// MARK: - ## 模块和源文件
//Swift 中的访问控制模型基于模块和源文件这两个概念。

//模块指的是独立的代码单元，框架或应用程序会作为一个独立的模块来构建和发布。在 Swift 中，一个模块可以使用 import 关键字导入另外一个模块。

//在 Swift 中，Xcode 的每个 target（例如框架或应用程序）都被当作独立的模块处理。如果你是为了实现某个通用的功能，或者是为了封装一些常用方法而将代码打包成独立的框架，这个框架就是 Swift 中的一个模块。当它被导入到某个应用程序或者其他框架时，框架内容都将属于这个独立的模块。

//源文件就是 Swift 中的源代码文件，它通常属于一个模块，即一个应用程序或者框架。尽管我们一般会将不同的类型分别定义在不同的源文件中，但是同一个源文件也可以包含多个类型、函数之类的定义。


// MARK: - ## 访问级别
//Swift 为代码中的实体提供了三种不同的访问级别。这些访问级别不仅与源文件中定义的实体相关，同时也与源文件所属的模块相关。

/**
 - public：可以访问同一模块源文件中的任何实体，在模块外也可以通过导入该模块来访问源文件里的所有实体。通常情况下，框架中的某个接口可以被任何人使用时，你可以将其设置为 public 级别。
 - internal：可以访问同一模块源文件中的任何实体，但是不能从模块外访问该模块源文件中的实体。通常情况下，某个接口只在应用程序或框架内部使用时，你可以将其设置为 internal 级别。
 - private：限制实体只能在所在的源文件内部使用。使用 private 级别可以隐藏某些功能的实现细节。
 */

//>注意
//Swift 中的 private 访问级别不同于其他语言，它的范围限于源文件，而不是声明范围内。这就意味着，一个类型可以访问其所在源文件中的所有 private 实体，<mark>但是如果它的扩展定义在其他源文件中，那么它的扩展就不能访问它在这个源文件中定义的 private 实体。

// MARK: - ### 访问级别基本原则

//Swift 中的访问级别遵循一个基本原则：<mark>不可以在某个实体中定义访问级别更高的实体。

//- 一个 public 访问级别的变量，其类型的访问级别不能是 internal 或 private。因为无法保证变量的类型在使用变量的地方也具有访问权限。

//- 函数的访问级别不能高于它的参数类型和返回类型的访问级别。因为如果函数定义为 public 而参数类型或者返回类型定义为 internal 或 private，就会出现函数可以在任何地方被访问，但是它的参数类型和返回类型却不可以。

// MARK: - ### 默认访问级别

//默认为 internal 级别（有一些例外情况，稍后会进行说明）。

// MARK: - ### 单元测试 target 的访问级别
//<mark>然而，如果在导入应用程序模块的语句前使用 @testable 特性，然后在允许测试的编译设置（Build Options -> Enable Testability）下编译这个应用程序模块，单元测试 target 就可以访问应用程序模块中所有 internal 级别的实体。

// MARK: - ### 元组类型

//元组的访问级别将由元组中访问级别最严格的类型来决定。例如，如果你构建了一个包含两种不同类型的元组，其中一个类型为 internal 级别，另一个类型为 private 级别，那么这个元组的访问级别为 private。

//>注意
//元组不同于类、结构体、枚举、函数那样有单独的定义。元组的访问级别是在它被使用时自动推断出的，而无法明确指定。

// MARK: - ### 函数类型

//函数的访问级别根据访问级别最严格的参数类型或返回类型的访问级别来决定。但是，如果这种访问级别不符合函数定义所在环境的默认访问级别，那么就需要明确地指定该函数的访问级别。
/**
 //一个名为 someFunction 的全局函数,这种写法，代码将无法通过编译：
 func someFunction() -> (SomeInternalClass, SomePrivateClass) {
 // 此处是函数实现部分
 }
 
 因为该函数返回类型的访问级别是 private，所以你必须使用 private 修饰符，明确指定该函数的访问级别：
 */

// MARK: - ## 子类
//子类的访问级别不得高于父类的访问级别。例如，父类的访问级别是 internal，子类的访问级别就不能是 public。

//可以通过重写为继承来的类成员提供更高的访问级别。

public class A {
    private func someMethod() {}
}

internal class B: A {
    //重写方法并指定为 internal 级别。
    override internal func someMethod() {}
}

// MARK: - ### Getter 和 Setter

//常量、变量、属性、下标的 Getters 和 Setters 的访问级别和它们所属类型的访问级别相同。

//Setter 的访问级别可以低于对应的 Getter 的访问级别，这样就可以控制变量、属性或下标的读写权限。

//>注意
//这个规则同时适用于存储型属性和计算型属性。即使你不明确指定存储型属性的 Getter 和 Setter，Swift 也会隐式地为其创建 Getter 和 Setter，用于访问该属性的后备存储。
struct TrackedString {
    //numberOfEdits 属性的 Getter 依然是默认的访问级别 internal，但是 Setter 的访问级别是 private
    private(set) var numberOfEdits = 0
    var value: String = "" {
        didSet {
            //用于记录属性 value 被修改的次数
            numberOfEdits += 1
        }
    }
}
public struct TrackedString2 {
    //numberOfEdits 属性的 Getter 是 public，但是 Setter 的访问级别是 private
    public private(set) var numberOfEdits = 0
    var value: String = "" {
        didSet {
            //用于记录属性 value 被修改的次数
            numberOfEdits += 1
        }
    }
}

// MARK: - 结构体默认的成员逐一构造器

//如果结构体中任意存储型属性的访问级别为 private，那么该结构体默认的成员逐一构造器的访问级别就是 private。否则，这种构造器的访问级别依然是 internal。

// MARK: - ## 协议
//注意
//如果你定义了一个 public 访问级别的协议，那么该协议的所有实现也会是 public 访问级别。这一点不同于其他类型，

// MARK: - ## 扩展
//你可以在访问级别允许的情况下对类、结构体、枚举进行扩展。扩展成员具有和原始类型成员一致的访问级别。

